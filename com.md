# zkSync LLVM Bug 复现命令

## 环境要求

本试验在 macOS（Apple Silicon M1）环境下执行。

### 需要提前下载的内容

1. **zksolc 编译器** - 两个版本：
   - zksolc v1.5.2（存在 bug 的版本）
   - zksolc v1.5.3（修复 bug 的版本）
2. **foundry-zksync-src** - zkSync 版本的 Foundry 工具链
3. **solc** - Solidity 编译器（solc-macosx-arm64-0.8.24-1.0.2）

---

## 步骤 0：设置环境变量

定义编译器路径，方便后续使用：

```bash
ZKSOLC_OLD="/Users/dk/Desktop/code/zksync/zksolc-macosx-arm64-v1.5.2"
SOLC_ZK="/Users/dk/Desktop/code/zksync/solc-macosx-arm64-0.8.24-1.0.2"
ZKSOLC_NEW="/Users/dk/Desktop/code/zksync/zksolc-macosx-arm64-v1.5.3"
```

### macOS 权限设置

在 macOS 上，下载的二进制文件需要设置执行权限并移除隔离属性：

```bash
chmod +x /Users/dk/Desktop/code/zksync/zksolc-macosx-arm64-v1.5.2  
xattr -l /Users/dk/Desktop/code/zksync/zksolc-macosx-arm64-v1.5.2
xattr -d com.apple.quarantine /Users/dk/Desktop/code/zksync/zksolc-macosx-arm64-v1.5.2

chmod +x /Users/dk/Desktop/code/zksync/zksolc-macosx-arm64-v1.5.3  
xattr -l /Users/dk/Desktop/code/zksync/zksolc-macosx-arm64-v1.5.3
xattr -d com.apple.quarantine /Users/dk/Desktop/code/zksync/zksolc-macosx-arm64-v1.5.3
```

---

## 步骤 1：编译合约

### 准备 standard.json 输入文件

使用 Solidity Standard JSON 格式作为编译输入，包含待测试的 MiscompileBitmap 合约源码：

```json
{
  "language": "Solidity",
  "sources": {
    "MiscompileBitmap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract MiscompileBitmap {\n    uint256 public data;\n\n    function setAllPairsUpTo(uint256 n) external {\n        uint256 x = 0;\n        for (uint256 i = 0; i <= n; i++) {\n            x |= (uint256(3) << (i << 1));\n        }\n        data = x;\n    }\n\n    function clearBorrow(uint256 reserveIndex) external {\n        uint256 bit = uint256(1) << (reserveIndex << 1);\n        data &= ~bit;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": { "enabled": true, "runs": 200 },
    "outputSelection": {
      "*": {
        "*": ["abi", "evm", "eravm.assembly"]
      }
    }
  }
}
```

### 使用两个版本的编译器分别编译

使用有 bug 的旧版本（v1.5.2）和修复后的新版本（v1.5.3）分别编译合约：

```bash
"$ZKSOLC_OLD" --solc "$SOLC_ZK" --standard-json < standard.json > out_old.json
"$ZKSOLC_NEW" --solc "$SOLC_ZK" --standard-json < standard.json > out_new.json
```

- `out_old.json`：使用 v1.5.2 编译的结果（包含 bug）
- `out_new.json`：使用 v1.5.3 编译的结果（已修复）

---

## 步骤 2：启动 zkSync 本地测试节点

使用 anvil-zksync 启动本地 zkSync 测试网络（在新终端窗口运行）：

```bash
anvil-zksync -vv
```

> **说明**：`-vv` 参数启用详细日志输出，方便调试。节点默认运行在 `http://localhost:8011`。

---

## 步骤 3：设置网络连接参数

定义 RPC 端点和测试账户私钥：

```bash
RPC="http://localhost:8011"
PK="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"
```

> **说明**：这是 anvil-zksync 的默认测试账户私钥，预装了测试 ETH。

---

## 步骤 4：部署合约

### 部署使用旧版编译器编译的合约（有 bug）

从 `out_old.json` 提取字节码并部署：

```bash
cast send --rpc-url http://localhost:8011 \
  --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 \
  --zksync \
  --create 0x0000008003000039000000400030043f0000000100200190000000220000c13d000000000201001900000060022002700000001502200197000000040020008c000000400000413d000000000301043b000000e003300270000000170030009c000000390000613d000000180030009c0000002a0000613d000000190030009c000000400000c13d000000240020008c000000400000413d0000000002000416000000000002004b000000400000c13d0000000401100370000000000101043b00000001011002100000001d021002df000000010300008a000000ff0010008c000000000302a019000000000100041a000000000113016f000000000010041b0000000001000019000000500001042e0000000001000416000000000001004b000000400000c13d0000002001000039000001000010044300000120000004430000001601000041000000500001042e000000240020008c000000400000413d0000000002000416000000000002004b000000400000c13d0000000401100370000000000101043b0000001e0010009c000000420000c13d0000001b0100004100000000001004350000001101000039000000040010043f0000001c0100004100000051000104300000000001000416000000000001004b000000400000c13d000000000100041a000000800010043f0000001a01000041000000500001042e00000000010000190000005100010430000000000300001900000000020000190000000104300210000000030540020f000000ff0040008c0000000005002019000000000225019f000000000013004b0000000103300039000000440000413d000000000020041b0000000001000019000000500001042e0000004f00000432000000500001042e00000051000104300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffff00000002000000000000000000000000000000400000010000000000000000000000000000000000000000000000000000000000000000000000000073d4a13a000000000000000000000000000000000000000000000000000000006430025500000000000000000000000000000000000000000000000000000000518b3ab200000000000000000000000000000000000000200000008000000000000000004e487b71000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000000000000000fffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000983b4808fcab980c1534eb50e8cff7f6d1c19f39caa899ad803a8952cec77507
  
blockHash            0x479c48525f08e451349aced669ff7ae6bd932cb14099a927b05e7948c865c904
blockNumber          1
contractAddress      0x588758d8a0Ad1162A6294f3C274753137E664aE0
```

> **重要**：记录部署的合约地址 `0x588758d8a0Ad1162A6294f3C274753137E664aE0`。

### 部署使用新版编译器编译的合约（已修复）

从 `out_new.json` 提取字节码并部署：

```bash
cast send --rpc-url http://localhost:8011 \
  --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 \
  --zksync \
  --create 0x0000008003000039000000400030043f0000000100200190000000220000c13d000000000201001900000060022002700000001502200197000000040020008c000000400000413d000000000301043b000000e003300270000000170030009c000000390000613d000000180030009c0000002a0000613d000000190030009c000000400000c13d000000240020008c000000400000413d0000000002000416000000000002004b000000400000c13d0000000401100370000000000101043b00000001011002100000001d021002df000000010300008a000000ff0010008c000000000302a019000000000100041a000000000113016f000000000010041b0000000001000019000000500001042e0000000001000416000000000001004b000000400000c13d0000002001000039000001000010044300000120000004430000001601000041000000500001042e000000240020008c000000400000413d0000000002000416000000000002004b000000400000c13d0000000401100370000000000101043b0000001e0010009c000000420000c13d0000001b01000041000000000010043f0000001101000039000000040010043f0000001c0100004100000051000104300000000001000416000000000001004b000000400000c13d000000000100041a000000800010043f0000001a01000041000000500001042e00000000010000190000005100010430000000000300001900000000020000190000000104300210000000030540020f000000ff0040008c0000000005002019000000000225019f000000000013004b0000000103300039000000440000413d000000000020041b0000000001000019000000500001042e0000004f00000432000000500001042e00000051000104300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffff00000002000000000000000000000000000000400000010000000000000000000000000000000000000000000000000000000000000000000000000073d4a13a000000000000000000000000000000000000000000000000000000006430025500000000000000000000000000000000000000000000000000000000518b3ab200000000000000000000000000000000000000200000008000000000000000004e487b71000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024000000000000000000000000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000bf50b471dbb1d51e351cc35b3ecef964d8e707e34f7efa2a023f4829a445f4fa
  
  
blockHash            0xe63ce59ba89aa5839378352959e1a0b47df4b3cd1a1b18a5e7be00d38a750cd2
blockNumber          3
contractAddress      0x6B828bcb33305478cd7d27eB323F5C5B7b4aFdbe
```

> **重要**：记录部署的合约地址 `0x6B828bcb33305478cd7d27eB323F5C5B7b4aFdbe`。

### 保存合约地址为环境变量

方便后续调用合约函数：

```bash
ADDR_OLD="0x588758d8a0Ad1162A6294f3C274753137E664aE0"
ADDR_NEW="0x6B828bcb33305478cd7d27eB323F5C5B7b4aFdbe"
```

---

## 步骤 5：测试合约行为

### 测试旧版本合约（有 bug）

#### 5.1 调用 setAllPairsUpTo 函数

设置位图，对索引 0 到 120 的所有位对进行设置：

```bash
cast send --rpc-url "$RPC" --private-key "$PK" --zksync \
  "$ADDR_OLD" "setAllPairsUpTo(uint256)" 120
```

#### 5.2 读取 data 值

查看设置后的位图数据：

```bash
cast call --rpc-url "$RPC" "$ADDR_OLD" "data()(uint256)"
```

**预期结果**：`7067388259113537318333190002971674063309935587502475832486424805170479103`

#### 5.3 调用 clearBorrow 函数

清除索引 80 位置的借款标志位：

```bash
cast send --rpc-url "$RPC" --private-key "$PK" --zksync \
  "$ADDR_OLD" "clearBorrow(uint256)" 80
```

#### 5.4 再次读取 data 值

查看清除操作后的位图数据：

```bash
cast call --rpc-url "$RPC" "$ADDR_OLD" "data()(uint256)"
```

**实际结果（bug）**：`26959946667150639791744011812357824837229774757108006441791745163264`  
**说明**：由于编译器 bug，清除操作错误地清除了多个位，而不是只清除单个位。

---

### 测试新版本合约（已修复）

#### 5.5 调用 setAllPairsUpTo 函数

设置位图，对索引 0 到 120 的所有位对进行设置：

```bash
cast send --rpc-url "$RPC" --private-key "$PK" --zksync \
  "$ADDR_NEW" "setAllPairsUpTo(uint256)" 120
```

#### 5.6 读取 data 值

查看设置后的位图数据：

```bash
cast call --rpc-url "$RPC" "$ADDR_NEW" "data()(uint256)"
```

**预期结果**：`7067388259113537318333190002971674063309935587502475832486424805170479103`

#### 5.7 调用 clearBorrow 函数

清除索引 80 位置的借款标志位：

```bash
cast send --rpc-url "$RPC" --private-key "$PK" --zksync \
  "$ADDR_NEW" "clearBorrow(uint256)" 80
```

#### 5.8 再次读取 data 值

查看清除操作后的位图数据：

```bash
cast call --rpc-url "$RPC" "$ADDR_NEW" "data()(uint256)"
```

**实际结果（正确）**：`7067388259113537318333188541470036732407017383817643116203405149237936127`  
**说明**：使用修复后的编译器，清除操作正确地只清除了单个位，其他位保持不变。

---

## 步骤 6：结果对比

### 数据对比表

| 合约版本 | 操作 | data 值 |
|---------|------|---------|
| 旧版本（bug） | setAllPairsUpTo(120) | 7067388259113537318333190002971674063309935587502475832486424805170479103 |
| 旧版本（bug） | clearBorrow(80) 后 | 26959946667150639791744011812357824837229774757108006441791745163264 ❌ |
| 新版本（正常） | setAllPairsUpTo(120) | 7067388259113537318333190002971674063309935587502475832486424805170479103 |
| 新版本（正常） | clearBorrow(80) 后 | 7067388259113537318333188541470036732407017383817643116203405149237936127 ✅ |

### Bug 影响说明

- **旧版本**：`clearBorrow` 函数错误地清除了大量位，导致数据严重错误
- **新版本**：`clearBorrow` 函数正确地只清除了指定位置的单个位
- **数值差异**：旧版本的结果比新版本小很多，说明过多的位被错误清除

---

## 总结

本复现演示了 zkSync LLVM 编译器在处理位操作时的严重 bug（CVE-2024-45056），该 bug 会导致位清除操作错误地清除多个位而不是单个位，这在 DeFi 协议（如 Aave V3）中会造成严重的资金安全问题。

详细的技术分析请参阅 [zkSync-LLVM-Bug-分析.md](zkSync-LLVM-Bug-分析.md)。

