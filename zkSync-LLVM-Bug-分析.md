# zkSync LLVM 编译器 Bug 分析

**CVE-2024-45056：一个影响 Aave V3 zkSync 部署的严重编译器漏洞**

---

## 目录

1. [问题复现：一个简单的位操作测试](#1-问题复现一个简单的位操作测试)
2. [问题定位：谁引起的问题](#2-问题定位谁引起的问题)
3. [分析 Bug 原因](#3-分析 Bug 原因)
4. [Aave V3 zkSync 事件回顾](#4-Aave V3 zkSync 事件回顾)
5. [一些启发](#5-一些启发)
6. [参考资料](#6-参考资料)

---

## 1. 问题复现：一个简单的位操作测试

### 1.1 问题描述

我们编写了一个简单的智能合约来测试位图操作。这个合约模拟了 DeFi 协议（如 Aave）中常见的用户配置管理场景：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract MiscompileBitmap {
    uint256 public data;

    // 初始化：把 [0..n] 的 borrow/collateral 两位都置 1
    function setAllPairsUpTo(uint256 n) external {
        uint256 x = 0;
        for (uint256 i = 0; i <= n; i++) {
            x |= (uint256(3) << (i << 1)); // 0b11 at (2*i)
        }
        data = x;
    }

    // 清除 borrow 位：与 Aave 的典型写法一致
    function clearBorrow(uint256 reserveIndex) external {
        uint256 bit = uint256(1) << (reserveIndex << 1);
        data &= ~bit; 
    }
}
```

问题：如何优化 (xor (shl 1, x), -1) ？

```
        bit = (1) << (reserveIndex << 1);
        data &= ~bit; 
        
获取掩码思路1:
   
        数1：
        0000000000000000000000000000000000000000000000000000000000000001
        假设左移2位：
        0000000000000000000000000000000000000000000000000000000000000100
        取反：
        1111111111111111111111111111111111111111111111111111111111111011

获取掩码思路2:        
        nCPI0_8
        十进制：18446744073709551614   
        二进制：1111111111111111111111111111111111111111111111111111111111111110
 				
 				将nCPI0_8循环左移2位：
 				二进制：1111111111111111111111111111111111111111111111111111111111111011
 				
 				
 				fold (xor (shl 1, x), -1) -> (rotl ~1, x)
```



### 1.2 预期行为 vs 实际行为

**测试场景：**

```solidity
b.setAllPairsUpTo(120);     // 设置前 121 个资产的标志位（共 242 位）
uint256 before = b.data();  // before = ?
b.clearBorrow(80);          // 只清除第 160 位（80 * 2 = 160）
uint256 after = b.data();   // after = ?
```

**实际测试数据：**

```
setAllPairsUpTo(120) 的结果：
十进制: 7067388259113537318333190002971674063309935587502475832486424805170479103
二进制: 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

(共 242 个 1，对应 121 个资产的 242 个标志位)
```

**预期结果：**
```
clearBorrow(80) 应该只清除第 160 位：
二进制: 11111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
↑ 只有第160位是0 ，有 241 个 1。
```

**实际结果（在有 bug 的 zksolc 编译器上）：**
```
clearBorrow(80) 的实际结果：
十进制: 26959946667150639791744011812357824837229774757108006441791745163264
二进制: 
11111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
第 0-160 位全部被清零了


仔细观察，不光低位收到影响，高位也受到影响：
00000000000000000011111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000       

```

分析这个过程：

```
初始值：
7067388259113537318333190002971674063309935587502475832486424805170479103

11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

想得到掩码：
11111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

通过 取反 得到掩码；

计算：
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
&
(～00000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)

得到，预期结果：
7067388259113537318333188541470036732407017383817643116203405149237936127

11111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111



能不能快速的得到掩码？减少运算？
0000000000000000000000000000000000000000000000000000000000000001
优化方案如下：对下方这个数字进行循环左移的操作：

1111111111111111111111111111111111111111111111111111111111111110


在执行中：
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111110

循环左移后得到掩码：
0000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000



计算：
0000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
&
0000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000



实际结果：
26959946667150639791744011812357824837229774757108006441791745163264


11111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000


00000000000000000011111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000


```



### 1.3 Bug 的影响

这个 bug 导致了一个极其严重的问题：
- ✅ **预期**：清除 1 个位（第 160 位），保留 241 个 1
- ❌ **实际**：清除了 161 个位（第 0-160 位全部被清零），只剩 81 个 1，高位也被置为0。

在 DeFi 场景中，这意味着：
- 用户归还索引为 80 的资产借款后
- 索引 0-79 的所有资产（共 80 个）的借款和抵押品标记都被错误清除

---

## 2. 问题定位：谁引起的问题

### 2.1 问题调查

（1）查看其他网络的AAVE V3实例

（2）查看ZKsync上Fork AAVE V3 的项目；

均没有问题，尝试定位ZKsync工具链的问题：

https://docs.zksync.io/zksync-protocol/era-vm/compiler/toolchain

![img](https://docs.zksync.io/images/zk-stack/compiler-toolchain.png)

```
Solidity 源代码 (正确)
      ↓ zksolc 编译
EVM 字节码 (正确)
      ↓ LLVM 中间表示
LLVM IR (正确)
      ↓ LLVM 优化器 ❌ Bug 在这里！
优化后的 LLVM IR (错误)
      ↓ zkEVM 代码生成
zkEVM 字节码 (错误)
```



### 2.2 根本原因

**问题出在 LLVM 编译器库的一个优化 pass 上**，而不是 zkSync 或 Aave 的代码。

- **受影响的组件**：LLVM（一个被广泛使用的编译器基础设施）
- **CVE 编号**：CVE-2024-45056
- **影响时间**：LLVM 2015 年至 2024 年 8 月的所有版本
- **影响范围**：所有使用 zksolc 1.5.3 之前版本编译的合约
  
  https://github.com/llvm/llvm-project/commit/e48237df95b49a36b8ffceb78c8a58f4be1b4344
  
  

---

## 3.分析 Bug 原因

### 3.1 Solidity 源码

```solidity
function clearBorrow(uint256 reserveIndex) external {
    uint256 bit = uint256(1) << (reserveIndex << 1);
    data &= ~bit;
}
```

代码含义：
```
bit     = 1 << (reserveIndex * 2)     // 创建只有目标位为 1 的掩码
~bit    = NOT bit                      // 取反，变成只有目标位为 0 的掩码
data   &= ~bit                         // 保留其他位，只清除目标位
```

### 3.2 LLVM 的错误优化

LLVM 优化器识别到了这个模式并尝试优化：

**原始表达式：**
```
result = data & ~(1 << (reserveIndex * 2))
       = data & (xor (shl 1, x), -1)
```

**LLVM 的优化：**
```
优化为: data & (rotl ~1, x)
       = data & (rotl 0xFFFFFFFFFFFFFFFE, x)
```

### 3.3 Bug 的根源：位宽不匹配

**问题点：**
- `~1` 在 LLVM 内部被表示为 **64 位**常量：`0xFFFFFFFFFFFFFFFE`
  
  ```
  64位表示: 1111111111111111111111111111111111111111111111111111111111111110
            (63个1 + 1个0)
  ```
  
- 但 zkEVM 使用 **256 位**寄存器
  ```
  256位应该是: 111...111110  (255个1 + 1个0)
  实际得到:     000...000111...111110  (192个0 + 63个1 + 1个0)
              高192位  低64位
  ```

### 3.4 旋转左移导致的错误

当我们执行 `rotl 0xFFFFFFFFFFFFFFFE, 160` 时：

**正确的 256 位版本（预期）：**
```
原始:  111...111110  (255个1 + 1个0 在最右)
       ← 左旋转 160 位
结果:  111...110111...111  (0 在位160，其他位都是1)
```

**错误的实际实现（64位常量被零扩展到256位）：**
```
原始:  000...000111...111110  (高192位是0，低64位是63个1+1个0)
       ← 左旋转 160 位
结果:  00.111...111000...000000  (高位部分的0被旋转到低位)
       ↑ 位161    ↑ 位0-159全是0！
       
0000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```

### 3.5 实际汇编代码证据

Certora 团队在分析 zkEVM 汇编时发现：

```assembly
; 错误的汇编代码
shl.s 1, r1, r1              ; r1 = reserveIndex << 1
rol @CPI0_60[0], r1, r1      ; r1 = rotl(0xFFFFFFFFFFFFFFFE, r1)
sload r3, r2                 ; r2 = data (从存储加载)
and r2, r1, r1               ; r1 = r2 & r1
sstore r3, r1                ; 存储回 data

; 其中 @CPI0_60[0] = 18446744073709551614 = 0xFFFFFFFFFFFFFFFE
```

这个常量 `0xFFFFFFFFFFFFFFFE` 只有 64 位宽度，这是 bug 的直接证据！

- ### 3.6 修复方案

  **LLVM 的修复**（commit [067f2e9](https://github.com/llvm/llvm-project/commit/067f2e9f18e1c92496202dc37428a89945f57c22)）：

  这个修复并不是单独修改某个函数，而是系统性地替换了多处使用 `getConstant(-1, ...)` 的地方。

  **核心问题**：`getConstant(-1, DL, VT)` 会创建一个有符号的 -1，在某些上下文中可能只使用 64 位表示。

  **修复的关键文件**：

  - `DAGCombiner.cpp` - 负责 DAG 优化的核心文件
  - `TargetLowering.cpp` - 目标平台相关的代码生成

  **实际修复代码示例**（在 DAGCombiner.cpp 中）：

  ```cpp
  // 修复前：在旋转优化中使用 getConstant
  if (TLI.isOperationLegalOrCustom(ISD::ROTL, VT) && N0Opcode == ISD::SHL &&
      isAllOnesConstant(N1) && isOneConstant(N0.getOperand(0))) {
    return DAG.getNode(ISD::ROTL, DL, VT, 
                       DAG.getConstant(~1, DL, VT),  // ❌ 问题代码
                       N0.getOperand(1));
  }
  
  // 修复后：使用 getAllOnesConstant 并手动清除最低位
  if (TLI.isOperationLegalOrCustom(ISD::ROTL, VT) && N0Opcode == ISD::SHL &&
      isAllOnesConstant(N1) && isOneConstant(N0.getOperand(0))) {
    return DAG.getNode(ISD::ROTL, DL, VT, 
                       DAG.getAllOnesConstant(DL, VT).clearBit(0),  // ✅ 修复
                       N0.getOperand(1));
  }
  ```

  **在 TargetLowering.cpp 中的修复**：

  ```cpp
  // 修复前
  Op = DAG.getNode(ISD::VP_XOR, dl, VT, Op, 
                   DAG.getConstant(-1, dl, VT), Mask, VL);  // ❌ -1 可能只有64位
  
  // 修复后
  Op = DAG.getNode(ISD::VP_XOR, dl, VT, Op, 
                   DAG.getAllOnesConstant(dl, VT), Mask, VL);  // ✅ 保证全位宽
  ```

  **修复原理**：

  - `getConstant(-1, ...)` → `getAllOnesConstant(...)`
  - `getAllOnesConstant` 确保根据目标类型 VT 创建**完整位宽**的全 1 常量
  - 对于 256 位的 zkEVM，会生成完整的 256 位全 1，而不是 64 位

  **zksolc 的应对**：

  - 在 zksolc 1.5.3 中集成了修复后的 LLVM 版本
  - 所有合约都需要重新编译和部署

---

## 4. Aave V3 zkSync 事件回顾

### 4.1 时间线

| 时间 | 事件 |
|---|---|
| **2024-08-21 15:30** | Aave Labs 在激活前测试中发现 UI 异常 |
| **同日稍后** | 发现更严重的问题：复杂操作后用户头寸消失 |
| **池子激活** | Aave V3 zkSync 正式上线 |
| **发现核心问题** | BGD Labs 介入，确认存在合约 bug |
| **立即响应** | Aave Guardian 紧急暂停整个池子 |
| **深度调查** | BGD Labs + Certora + Matter Labs 联合分析 |
| **2024-08-29** | 确认为 LLVM 编译器 bug，发布公告 |

### 4.2 为什么 Aave 能够安全发现？

**1. 多层测试流程：**
- 提案阶段的单元测试
- Fork 环境的集成测试
- 生产环境的 UI 层面测试（**在此发现**）

**2. 快速响应机制：**
- Aave Labs 立即联系 BGD Labs
- BGD Labs 立即联系 Aave Guardian
- Guardian 在池子为空时迅速暂停
- **零资金损失**

**3. 深度技术分析：**
- Certora 的形式化验证团队深入汇编层面
- Matter Labs 的编译器团队追溯到 LLVM
- 跨团队协作找到根本原因

---

## 5. 一些启发

### 5.1 编译器不是绝对可信的

**教训：**
- 即使是 LLVM 这样广泛使用、经过充分测试的编译器库，也可能存在 bug
- 这个 bug 从 2015 年就存在，直到 2024 年才被发现
- **不能完全依赖编译器的正确性**

**应对措施：**
- 在实际字节码层面进行测试和验证
- 使用形式化验证工具分析编译后的代码
- 关注编译器更新和安全公告

### 5.2 测试的局限性

### 5.3 多链部署的额外风险

### 5.4 形式化验证的价值

**Certora 如何发现问题的：**
1. 直接分析编译后的汇编代码
2. 发现了"魔法常量" `0xFFFFFFFFFFFFFFFE`
3. 识别出这是一个 64 位常量（不应该出现在 256 位系统中）
4. 追溯到 LLVM 的优化 pass

**传统测试 vs 形式化验证：**
```
单元测试: 测试特定输入 → 检查特定输出
模糊测试: 测试随机输入 → 检查属性
形式化验证: 分析所有可能路径 → 证明数学性质
汇编分析: 查看实际执行代码 → 发现编译问题 ← Certora 在这里
```

### 5.5 我们要做的事情

1. 收集编译器安全漏洞，做一些快速的测试；
2. 寻找历史合约（使用<1.15.3 编译器编译的代码），产看是否存在相关安全隐患



- ## 总结

  这个 bug 展示了现代软件开发的复杂性和脆弱性：

  1. **一个看似简单的位操作**，隐藏着深层的编译器问题
  2. **一个历史悠久的编译器**，存在了 9 年的优化 bug
  3. **一个经过充分测试的协议**，差点因为编译器问题遭受重大损失
  4. **一个多方协作的生态**，成功避免了灾难性后果

  这提醒我们：

  - 🔍 **永远不要停止测试**，包括对底层的测试
  - 🤝 **跨团队协作**是发现和解决复杂问题的关键
  - ⚡ **快速响应机制**可以将损失降到最低
  - 🛡️ **深度防御**：不要依赖任何单一的安全保障

---

## 6. 参考资料

### 官方报告
- [BGD Labs - Aave v3 ZKSync Activation Issue Report](https://governance.aave.com/t/bgd-aave-v3-zksync-activation-issue-report/18819)
- [Certora - Uncovered Compiler Bugs: How Certora Identified a Critical Error in LLVM](https://www.certora.com/blog/llvm-bug)
- [NVD - CVE-2024-45056 Detail](https://nvd.nist.gov/vuln/detail/CVE-2024-45056)

### 技术修复
- [LLVM Fix Commit](https://github.com/llvm/llvm-project/commit/067f2e9f18e1c92496202dc37428a89945f57c22)
- [zkSync Security Advisory](https://github.com/matter-labs/era-compiler-solidity/security/advisories/GHSA-fpx7-8vc6-frjj)
- [zkSync DevX Thread](https://x.com/zkSyncDevs/status/1829110498471621003)

### 相关代码
- [Aave V3 Origin - UserConfiguration.sol](https://github.com/aave-dao/aave-v3-origin/blob/main/src/core/contracts/protocol/libraries/configuration/UserConfiguration.sol#L87)
- 有问题的编译器 zksolc ：https://github.com/matter-labs/zksolc-bin/releases/tag/v1.5.2

### 测试代码
- `src/MiscompileBitmap.sol` - 问题复现合约



